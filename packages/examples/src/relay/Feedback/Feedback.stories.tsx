import { graphql } from "@nova/react";
import {
  getNovaDecorator,
  getNovaEnvironmentForStory,
  type WithNovaEnvironment,
  type StoryObjWithoutFragmentRefs,
  MockPayloadGenerator as PayloadGenerator,
  EventingInterceptor,
} from "@nova/react-test-utils/relay";
import type { Meta } from "@storybook/react";
import { userEvent, waitFor, within, expect } from "@storybook/test";
import { schema } from "../../testing-utils/schema";
import type { TypeMap } from "../../__generated__/schema.all.interface";
import { FeedbackComponent } from "./Feedback";
import type { FeedbackStoryQuery } from "./__generated__/FeedbackStoryQuery.graphql";
import * as React from "react";
import type { events } from "../../events/events";
import { fn } from "@storybook/test";
import { type withErrorBoundaryParameters } from "../../testing-utils/decorators";

type NovaParameters = WithNovaEnvironment<
  FeedbackStoryQuery,
  TypeMap,
  typeof FeedbackComponent
>;

const MockPayloadGenerator = new PayloadGenerator(schema);

const novaDecorator = getNovaDecorator(schema, {
  getEnvironmentOptions: () => ({
    storeOptions: {},
  }),
});

const meta = {
  component: FeedbackComponent,
  decorators: [novaDecorator],
  parameters: {
    novaEnvironment: {
      query: graphql`
        query FeedbackStoryQuery($id: ID!) @relay_test_operation {
          feedback(id: $id) {
            ...Feedback_feedbackFragment
          }
        }
      `,
      variables: { id: "42" },
      referenceEntries: {
        feedback: (data) => data.feedback,
      },
    },
  } satisfies NovaParameters,
} satisfies Meta<typeof FeedbackComponent>;

export default meta;
type Story = StoryObjWithoutFragmentRefs<typeof meta>;

export const AutoGeneratedDataOnly: Story = {};

export const Primary: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => sampleFeedback,
      },
    },
  } satisfies NovaParameters,
  play: async (context) => {
    const container = within(context.canvasElement);
    // Verify that value from relay resolvers come through
    await container.findByText("Feedback from resolvers: Feedback title");
  },
};

export const Liked: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => ({
          ...sampleFeedback,
          doesViewerLike: true,
        }),
      },
    },
  } satisfies NovaParameters,
};

const likeResolvers = {
  Feedback: () => sampleFeedback,
  FeedbackLikeMutationResult: () => ({
    feedback: {
      ...sampleFeedback,
      doesViewerLike: true,
    },
  }),
};

export const Like: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: likeResolvers,
    },
  } satisfies NovaParameters,
  play: async (context) => {
    const container = within(context.canvasElement);
    const likeButton = await container.findByRole("button", { name: "Like" });
    await userEvent.click(likeButton);

    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);

    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    mock.resolveMostRecentOperation((operation) => {
      return MockPayloadGenerator.generate(operation, likeResolvers);
    });
    await container.findByRole("button", { name: "Unlike" });
  },
};

const mockOnError = fn<[Error]>();

export const ArtificialFailureToShowcaseDecoratorBehaviorInCaseOfADevCausedError: Story =
  {
    parameters: {
      novaEnvironment: {
        enableQueuedMockResolvers: false,
      },
      errorBoundary: {
        onError: mockOnError,
      },
    } satisfies NovaParameters & withErrorBoundaryParameters,
    play: async (context) => {
      const {
        graphql: { mock },
      } = getNovaEnvironmentForStory(context);
      await waitFor(async () => {
        const operation = mock.getMostRecentOperation();
        await expect(operation).toBeDefined();
      });
      mock.rejectMostRecentOperation(new Error("Query failed"));

      await waitFor(() => {
        expect(mockOnError).toHaveBeenCalledTimes(1);
      });
      const call = mockOnError.mock.calls[0];
      expect(call[0].message).toBe("Query failed");
    },
  };

const FeedbackWithDeleteDialog = (
  props: React.ComponentProps<typeof FeedbackComponent>,
) => {
  const [open, setOpen] = React.useState(false);
  const [text, setText] = React.useState("");
  return (
    <EventingInterceptor<typeof events>
      eventMap={{
        onDeleteFeedback: (eventWrapper) => {
          setOpen(true);
          setText(eventWrapper.event.data().feedbackText);
          return Promise.resolve(undefined);
        },
        feedbackTelemetry: (eventWrapper) => {
          console.log("Telemetry event", eventWrapper.event.data());
          return Promise.resolve(eventWrapper);
        },
      }}
    >
      <FeedbackComponent {...props} />
      <dialog open={open}>
        <button onClick={() => setOpen(false)}>Cancel</button>
        Are you sure you want to delete feedback "{text}"
      </dialog>
    </EventingInterceptor>
  );
};

export const WithDeleteDialog: Story = {
  ...Primary,
  render: (args) => <FeedbackWithDeleteDialog {...args} />,
  play: async (context) => {
    const container = within(context.canvasElement);
    const deleteButton = await container.findByRole("button", {
      name: "Delete feedback",
    });
    await userEvent.click(deleteButton);
    const dialog = await container.findByRole("dialog");
    await expect(dialog).toBeInTheDocument();
  },
};

const sampleFeedback = {
  id: "42",
  message: {
    text: "Feedback title",
  },
  doesViewerLike: false,
  displayLabel: "Feedback from resolvers",
};
