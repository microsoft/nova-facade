import type { Meta, StoryObj } from "@storybook/react";
import { userEvent, within, waitFor, expect, fn } from "@storybook/test";
import {
  type UnknownOperation,
  type WithNovaEnvironment,
  EventingInterceptor,
  getNovaDecorator,
  getNovaEnvironmentForStory,
  getOperationName,
  getOperationType,
  MockPayloadGenerator as PayloadGenerator,
} from "@nova/react-test-utils/relay";
import type { TypeMap } from "../../__generated__/schema.all.interface";
import { FeedbackContainer } from "./FeedbackContainer";
import {
  type events,
  type FeedbackTelemetryEvent,
  eventTypes,
} from "../../events/events";
import { getSchema } from "../../testing-utils/getSchema";
import * as React from "react";
import {
  withErrorBoundary,
  type withErrorBoundaryParameters,
} from "../../testing-utils/deorators";

const schema = getSchema();

const MockPayloadGenerator = new PayloadGenerator(schema);

const telemetryEventMock =
  fn<[{ event: FeedbackTelemetryEvent; source: unknown }]>();

const meta: Meta<typeof FeedbackContainer> = {
  component: FeedbackContainer,
  decorators: [getNovaDecorator(schema)],
  render: () => (
    <EventingInterceptor<typeof events>
      eventMap={{
        feedbackTelemetry: telemetryEventMock,
      }}
    >
      <FeedbackContainer />
    </EventingInterceptor>
  ),
};

export default meta;
type Story = StoryObj<typeof meta>;

export const AutoGeneratedDataOnly: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const button = await canvas.findByRole("button", { name: "Like" });
    await expect(button).toBeInTheDocument();
  },
};

export const Primary: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => sampleFeedback,
      },
    },
  } satisfies WithNovaEnvironment<UnknownOperation, TypeMap>,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const button = await canvas.findByRole("button", { name: "Like" });
    await expect(button).toBeInTheDocument();
  },
};

export const Liked: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => ({
          ...sampleFeedback,
          doesViewerLike: true,
        }),
      },
    },
  } satisfies WithNovaEnvironment<UnknownOperation, TypeMap>,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const button = await canvas.findByRole("button", { name: "Unlike" });
    await expect(button).toBeInTheDocument();
  },
};

const likeResolvers = {
  Feedback: () => sampleFeedback,
  FeedbackLikeMutationResult: () => ({
    feedback: {
      ...sampleFeedback,
      doesViewerLike: true,
    },
  }),
};

export const Like: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: likeResolvers,
    },
  } satisfies WithNovaEnvironment<UnknownOperation, TypeMap>,
  play: async (context) => {
    const container = within(context.canvasElement);
    const likeButton = await container.findByRole("button", { name: "Like" });
    userEvent.click(likeButton);
    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);

    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    mock.resolveMostRecentOperation((operation) => {
      return MockPayloadGenerator.generate(operation, likeResolvers);
    });

    await container.findByRole("button", { name: "Unlike" });
    expect(telemetryEventMock).toHaveBeenCalledTimes(2);
    const call = telemetryEventMock.mock.calls[1];
    expect(call[0].event.data().operation).toBe("FeedbackLiked");
  },
};

export const LikeFailure: Story = {
  parameters: {
    novaEnvironment: {
      enableQueuedMockResolvers: false,
    },
  } satisfies WithNovaEnvironment<UnknownOperation, TypeMap>,
  play: async (context) => {
    const container = within(context.canvasElement);
    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);

    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    const operation = mock.getMostRecentOperation();
    const operationName = getOperationName(operation);
    const operationType = getOperationType(operation);
    expect(operationName).toEqual("FeedbackContainerQuery");
    expect(operationType).toEqual("query");
    mock.resolveMostRecentOperation((operation) => {
      return MockPayloadGenerator.generate(operation, {
        Feedback: () => sampleFeedback,
      });
    });
    const likeButton = await container.findByRole("button", { name: "Like" });
    userEvent.click(likeButton);
    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      expect(operation).toBeDefined();
    });
    const nextOperation = mock.getMostRecentOperation();
    const nextOperationName = getOperationName(nextOperation);
    const nextOperationType = getOperationType(nextOperation);
    expect(nextOperationName).toEqual("FeedbackComponent_LikeMutation");
    expect(nextOperationType).toEqual("mutation");
    mock.rejectMostRecentOperation(new Error("Like failed"));
    await container.findByText("Something went wrong");
  },
};

const mockOnError = fn<[Error]>();

export const QueryFailure: Story = {
  parameters: {
    novaEnvironment: {
      enableQueuedMockResolvers: false,
    },
    errorBoundary: {
      onError: mockOnError,
    },
  } satisfies WithNovaEnvironment<UnknownOperation, TypeMap> &
    withErrorBoundaryParameters,
  play: async (context) => {
    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);
    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    mock.rejectMostRecentOperation(new Error("Query failed"));

    await waitFor(() => {
      expect(mockOnError).toHaveBeenCalledTimes(1);
    });
    const call = mockOnError.mock.calls[0];
    expect(call[0].message).toBe("Query failed");
  },
};

export const Loading: Story = {
  parameters: {
    novaEnvironment: {
      enableQueuedMockResolvers: false,
    },
  } satisfies WithNovaEnvironment<UnknownOperation, TypeMap>,
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const loadingElement = await canvas.findByText("Loading...");
    await expect(loadingElement).toBeInTheDocument();
  },
};

const sampleFeedback = {
  id: "42",
  message: {
    text: "Feedback title",
  },
  doesViewerLike: false,
};
