import { graphql } from "react-relay";
import {
  getNovaDecorator,
  getNovaEnvironmentForStory,
  type WithNovaEnvironment,
  EventingInterceptor,
  getOperationName,
  getOperationType,
  type StoryObjWithoutFragmentRefs,
} from "@nova/react-test-utils/relay";
import { MockPayloadGenerator } from "relay-test-utils";
import type { Meta } from "@storybook/react";
import { userEvent, waitFor, within, expect, fn } from "@storybook/test";
import type { TypeMap } from "../../__generated__/schema.all.interface";
import { FeedbackComponent } from "./Feedback";
import type { FeedbackStoryRelayQuery } from "./__generated__/FeedbackStoryRelayQuery.graphql";
import { schema } from "../../testing-utils/schema";
import * as React from "react";
import type { events } from "../../events/events";
import { RecordSource, Store } from "relay-runtime";
import { type withErrorBoundaryParameters } from "../../testing-utils/decorators";

type NovaParameters = WithNovaEnvironment<FeedbackStoryRelayQuery, TypeMap>;

const novaDecorator = getNovaDecorator(schema, {
  getEnvironmentOptions: () => ({
    store: new Store(new RecordSource()),
  }),
  // We add this to verify scenario of using relay's MockPayloadGenerator
  generateFunction: (operation, mockResolvers) => {
    const result = MockPayloadGenerator.generateWithDefer(
      operation,
      mockResolvers ?? null,
      {
        mockClientData: true,
        generateDeferredPayload: true,
      },
    );

    return result;
  },
});

const meta = {
  component: FeedbackComponent,
  decorators: [novaDecorator],
  parameters: {
    novaEnvironment: {
      query: graphql`
        query FeedbackStoryRelayQuery($id: ID!) @relay_test_operation {
          feedback(id: $id) {
            ...Feedback_feedbackRelayFragment
          }
          viewData {
            ...Feedback_viewDataRelayFragment
          }
        }
      `,
      variables: { id: "42" },
      referenceEntries: {
        feedback: (data) => data?.feedback,
        viewData: (data) => data?.viewData,
      },
      resolvers: {
        ViewData: () => ({
          viewDataField: "View data field",
          likeLabel: "Like",
          unlikeLabel: "Unlike",
          numberOfLikesLabel: "You have {count} likes",
        }),
      },
    },
  } satisfies NovaParameters,
} satisfies Meta<typeof FeedbackComponent>;

export default meta;
type Story = StoryObjWithoutFragmentRefs<typeof meta>;

export const AutoGeneratedDataOnly: Story = {};

export const Primary: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => sampleFeedback,
      },
    },
  } satisfies NovaParameters,
};

export const Liked: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => ({
          ...sampleFeedback,
          doesViewerLike: true,
        }),
      },
    },
  } satisfies NovaParameters,
};

const likeResolvers = {
  FeedbackLikeMutationResult: () => ({
    feedback: {
      ...sampleFeedback,
      doesViewerLike: true,
    },
  }),
};

export const Like: Story = {
  parameters: Primary.parameters,
  play: async (context) => {
    const container = within(context.canvasElement);
    const likeButton = await container.findByRole("button", { name: "Like" });
    await userEvent.click(likeButton);

    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);

    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    mock.resolveMostRecentOperation((operation) => {
      return MockPayloadGenerator.generate(operation, likeResolvers);
    });
    await container.findByRole("button", { name: "Unlike" });
  },
};

const mockOnError = fn<[Error]>();

export const ArtificialFailureToShowcaseDecoratorBehaviorInCaseOfADevCausedError: Story =
  {
    parameters: {
      novaEnvironment: {
        enableQueuedMockResolvers: false,
      },
      errorBoundary: {
        onError: mockOnError,
      },
    } satisfies NovaParameters &
      withErrorBoundaryParameters,
    play: async (context) => {
      const {
        graphql: { mock },
      } = getNovaEnvironmentForStory(context);
      await waitFor(async () => {
        const operation = mock.getMostRecentOperation();
        await expect(operation).toBeDefined();
      });
      mock.rejectMostRecentOperation(new Error("Query failed"));

      await waitFor(() => {
        expect(mockOnError).toHaveBeenCalledTimes(1);
      });
      const call = mockOnError.mock.calls[0];
      expect(call[0].message).toBe("Query failed");
    },
  };

export const LikeFailure: Story = {
  parameters: {
    novaEnvironment: {
      enableQueuedMockResolvers: false,
    },
  } satisfies NovaParameters,
  play: async (context) => {
    const container = within(context.canvasElement);
    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);

    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    const operation = mock.getMostRecentOperation();
    const operationName = getOperationName(operation);
    const operationType = getOperationType(operation);
    expect(operationName).toEqual("FeedbackStoryRelayQuery");
    expect(operationType).toEqual("query");
    mock.resolveMostRecentOperation((operation) => {
      return MockPayloadGenerator.generate(
        operation,
        {
          Feedback: () => sampleFeedback,
          ViewData: () => ({
            viewDataField: "View data field",
            likeLabel: "Like",
            unlikeLabel: "Unlike",
            numberOfLikesLabel: "You have {count} likes",
          }),
        },
        { mockClientData: true },
      );
    });
    const likeButton = await container.findByRole("button", {
      name: "Like",
    });
    userEvent.click(likeButton);
    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      expect(operation).toBeDefined();
    });
    const nextOperation = mock.getMostRecentOperation();
    const nextOperationName = getOperationName(nextOperation);
    const nextOperationType = getOperationType(nextOperation);
    expect(nextOperationName).toEqual("FeedbackComponent_RelayLikeMutation");
    expect(nextOperationType).toEqual("mutation");
    mock.rejectMostRecentOperation(new Error("Like failed"));
    await container.findByText("Something went wrong");
  },
};

const FeedbackWithDeleteDialog = (
  props: React.ComponentProps<typeof FeedbackComponent>,
) => {
  const [open, setOpen] = React.useState(false);
  const [text, setText] = React.useState("");
  return (
    <EventingInterceptor<typeof events>
      eventMap={{
        onDeleteFeedback: (eventWrapper) => {
          setOpen(true);
          setText(eventWrapper.event.data().feedbackText);
          return Promise.resolve(undefined);
        },
        feedbackTelemetry: (eventWrapper) => {
          console.log("Telemetry event", eventWrapper.event.data());
          return Promise.resolve(eventWrapper);
        },
      }}
    >
      <FeedbackComponent {...props} />
      <dialog open={open}>
        <button onClick={() => setOpen(false)}>Cancel</button>
        Are you sure you want to delete feedback "{text}"
      </dialog>
    </EventingInterceptor>
  );
};

export const WithDeleteDialog: Story = {
  ...Primary,
  render: (args) => <FeedbackWithDeleteDialog {...args} />,
  play: async (context) => {
    const container = within(context.canvasElement);
    const deleteButton = await container.findByRole("button", {
      name: "Delete feedback",
    });
    await userEvent.click(deleteButton);
    const dialog = await container.findByRole("dialog");
    await expect(dialog).toBeInTheDocument();
  },
};

const sampleFeedback = {
  id: "42",
  message: {
    text: "Feedback title",
  },
  doesViewerLike: false,
};
