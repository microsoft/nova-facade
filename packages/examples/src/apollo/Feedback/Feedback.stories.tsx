import { graphql } from "@nova/react";
import {
  EventingInterceptor,
  getNovaDecorator,
  getNovaEnvironmentForStory,
  type WithNovaEnvironment,
  type StoryObjWithoutFragmentRefs,
} from "@nova/react-test-utils/apollo";
import type { Meta } from "@storybook/react-vite";
import { expect, fn, userEvent, waitFor, within } from "storybook/test";
import type { TypeMap } from "../../__generated__/schema.all.interface";
import { FeedbackComponent } from "./Feedback";
import type { FeedbackStoryQuery } from "./__generated__/FeedbackStoryQuery.graphql";
import * as React from "react";
import type { events } from "../../events/events";
import { cacheConfig } from "../../testing-utils/apolloCacheConfig";
import type { withErrorBoundaryParameters } from "../../testing-utils/decorators";
import { schema } from "../../testing-utils/schema";
import { defaultNodeResolver } from "../../testing-utils/resolvers";

type NovaParameters = WithNovaEnvironment<FeedbackStoryQuery, TypeMap>;

const meta = {
  component: FeedbackComponent,
  decorators: [getNovaDecorator(schema, { cache: cacheConfig })],
  parameters: {
    novaEnvironment: {
      query: graphql`
        query FeedbackStoryQuery($id: ID!) @relay_test_operation {
          feedback(id: $id) {
            ...Feedback_feedbackFragment
          }
        }
      `,
      variables: { id: "42" },
      referenceEntries: {
        feedback: (data) => data?.feedback,
      },
      resolvers: {
        Node: defaultNodeResolver,
      },
    },
  } satisfies NovaParameters,
} satisfies Meta<typeof FeedbackComponent>;

export default meta;
type Story = StoryObjWithoutFragmentRefs<typeof meta>;

export const AutoGeneratedDataOnly: Story = {};

export const Primary: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => sampleFeedback,
      },
    },
  } satisfies NovaParameters,
};

export const Liked: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => ({
          ...sampleFeedback,
          doesViewerLike: true,
        }),
      },
    },
  } satisfies NovaParameters,
};

export const Like: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => sampleFeedback,
        FeedbackLikeMutationResult: () => ({
          feedback: {
            ...sampleFeedback,
            doesViewerLike: true,
          },
        }),
      },
    },
  } satisfies NovaParameters,
  play: async (context) => {
    const container = within(context.canvasElement);
    const likeButton = await container.findByRole("button", { name: "Like" });
    await userEvent.click(likeButton);

    await container.findByRole("button", { name: "Unlike" });
  },
};

const mockOnError = fn<(error: Error) => void>();

export const ArtificialFailureToShowcaseDecoratorBehaviorInCaseOfADevCausedError: Story =
  {
    parameters: {
      novaEnvironment: {
        enableQueuedMockResolvers: false,
      },
      errorBoundary: {
        onError: mockOnError,
      },
    } satisfies NovaParameters & withErrorBoundaryParameters,
    play: async (context) => {
      const {
        graphql: { mock },
      } = getNovaEnvironmentForStory(context);
      await waitFor(async () => {
        const operation = mock.getMostRecentOperation();
        await expect(operation).toBeDefined();
      });
      await mock.rejectMostRecentOperation(new Error("Query failed"));

      await waitFor(() => {
        expect(mockOnError).toHaveBeenCalledTimes(1);
      });
      const call = mockOnError.mock.calls[0];
      expect(call[0].message).toBe("Query failed");
    },
  };

const FeedbackWithDeleteDialog = (
  props: React.ComponentProps<typeof FeedbackComponent>,
) => {
  const [open, setOpen] = React.useState(false);
  const [text, setText] = React.useState("");
  return (
    <EventingInterceptor<typeof events>
      eventMap={{
        onDeleteFeedback: (eventWrapper) => {
          setOpen(true);
          setText(eventWrapper.event.data().feedbackText);
          return Promise.resolve(undefined);
        },
        feedbackTelemetry: (eventWrapper) => {
          console.log("Telemetry event", eventWrapper.event.data());
          return Promise.resolve(eventWrapper);
        },
      }}
    >
      <FeedbackComponent {...props} />

      <dialog open={open}>
        <button onClick={() => setOpen(false)}>Cancel</button>
        Are you sure you want to delete feedback "{text}"
      </dialog>
    </EventingInterceptor>
  );
};

export const WithDeleteDialog: Story = {
  ...Primary,
  render: (args) => <FeedbackWithDeleteDialog {...args} />,
  play: async (context) => {
    const container = within(context.canvasElement);
    const deleteButton = await container.findByRole("button", {
      name: "Delete feedback",
    });
    await userEvent.click(deleteButton);
    const dialog = await container.findByRole("dialog");
    await expect(dialog).toBeInTheDocument();
  },
};

const sampleFeedback = {
  id: "feedback:42",
  message: {
    text: "Feedback title",
  },
  doesViewerLike: false,
};
