import type { Meta, StoryObj } from "@storybook/react";
import { userEvent, within, waitFor, expect } from "@storybook/test";
import {
  type UnknownOperation,
  type WithNovaEnvironment,
  getNovaDecorator,
  MockPayloadGenerator,
  getNovaEnvironmentForStory,
} from "@nova/react-test-utils/apollo";
import { getSchema } from "../../testing-utils/getSchema";
import type { TypeMap } from "../../__generated__/schema.all.interface";
import { FeedbackContainer } from "./FeedbackContainer";
import { cacheConfig } from "../../testing-utils/apolloCacheConfig";

const schema = getSchema();

type NovaParams = WithNovaEnvironment<UnknownOperation, TypeMap>;

const meta = {
  component: FeedbackContainer,
  decorators: [getNovaDecorator(schema, { cache: cacheConfig })],
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => ({
          id: "feedback:42",
        }),
        Node: ({ args }) => {
          console.log("args", args);
          const { id } = args as { id: string };

          if (id.startsWith("feedback:")) {
            return {
              __typename: "Feedback",
              id,
            };
          }
          return undefined;
        },
      },
    },
  } satisfies NovaParams,
} satisfies Meta<typeof FeedbackContainer>;

export default meta;
type Story = StoryObj<typeof meta>;

export const AutoGeneratedDataOnly: Story = {};

export const Primary: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => sampleFeedback,
      },
    },
  } satisfies NovaParams,
};

export const Liked: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => ({
          ...sampleFeedback,
          doesViewerLike: true,
        }),
      },
    },
  } satisfies NovaParams,
};

export const Like: Story = {
  parameters: {
    novaEnvironment: {
      resolvers: {
        Feedback: () => sampleFeedback,
        FeedbackLikeMutationResult: () => ({
          feedback: {
            ...sampleFeedback,
            doesViewerLike: true,
          },
        }),
      },
    },
  } satisfies NovaParams,
  play: async ({ canvasElement }) => {
    const container = within(canvasElement);
    const likeButton = await container.findByRole("button", { name: "Like" });
    userEvent.click(likeButton);
  },
};

export const LikeFailure: Story = {
  parameters: {
    novaEnvironment: {
      enableQueuedMockResolvers: false,
    },
  } satisfies NovaParams,
  play: async (context) => {
    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);

    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    await mock.resolveMostRecentOperation((operation) =>
      MockPayloadGenerator.generate(operation, {
        Feedback: () => sampleFeedback,
      }),
    );
    await Like.play?.(context);
    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      expect(operation).toBeDefined();
    });
    mock.rejectMostRecentOperation(new Error("Like failed"));
    const container = within(context.canvasElement);
    await container.findByText("Something went wrong");
  },
};

export const QueryFailure: Story = {
  parameters: {
    novaEnvironment: {
      enableQueuedMockResolvers: false,
    },
  } satisfies NovaParams,
  play: async (context) => {
    const {
      graphql: { mock },
    } = getNovaEnvironmentForStory(context);
    await waitFor(async () => {
      const operation = mock.getMostRecentOperation();
      await expect(operation).toBeDefined();
    });
    await mock.rejectMostRecentOperation(new Error("Query failed"));
  },
};

export const Loading: Story = {
  parameters: {
    novaEnvironment: {
      enableQueuedMockResolvers: false,
    },
  } satisfies NovaParams,
};

const sampleFeedback = {
  id: "feedback:42",
  message: {
    text: "Feedback title",
  },
  doesViewerLike: false,
};
